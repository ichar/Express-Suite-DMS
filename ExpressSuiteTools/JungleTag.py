"""
Rendering object hierarchies as Trees multiple tags per page possible.
Tags on serveral pages may share status.

$Id: JungleTag.py, v 1.0 2007/08/30 12:00:00 Exp $

*** Checked 04/06/2009 ***

"""
__version__ = '$Revision: 1.0 $'[11:-2]

from zLOG import LOG, ERROR, INFO, DEBUG

from types import StringType
from urllib import unquote as url_unquote 
from string import join, split, rfind, replace

from DocumentTemplate.DT_Util import *
from DocumentTemplate.DT_String import String

from Products.CMFCore.utils import getToolByName

from TreeDisplay.TreeTag import encode_seq, decode_seq
from DepartmentDictionary import departmentDictionary

from Utils import joinpath, splitpath

from CustomObjects import CustomDefs, CustomCheckFolders

_img_postfix = ['_closed', '', '_opened'] # used to translate item_state to img tag src
transmitted_args = ('sort_order', 'state_id', 'state_url', 'meta_types', 'dynamic_item_id', 'parent_url')


def _IsDebug( context ):
    return context.getPortalObject().aq_parent.getProperty('DEBUG_JungleTag')

class Jungle:
    """
        Renders DTML tag 'jungle' which represent object tree widget based on catalog tool.
        
        Syntax:
        
          jungle tag syntax::

            <dtml-jungle [VariableName|expr="VariableExpression"]>...</dtml-jungle>

          The jungle tag is a block tag. It renders a dynamic tree widget in
          HTML. The root of the tree is given by variable name or expression,
          if present, otherwise it defaults to the current object. The tree
          block is rendered for each tree node, with the mybrains instance of
          node pushed onto the DTML namespace.

          Tag have three modes of rendering:

            1. **Static** (default).
               Similar to standard tree tag - page reload after the node is
               opened or closed.
            2. **Pseudo dynamic**.
               All tree contents loading into single page and closing/opening
               via javascripts without page reloading.
            3. **Dynamic**.
               As in static mode only open branches contents loading into page.
               But page reloading doesn't happen because contents of closed
               branches downloading when it needed with use of HTTP requests
               generated by javascript. This mode working only for IE (from
               late versions of 5.0) and Mozilla (from 0.9.7).

          Javascripts used in dynamic modes contained into *skins/common/jungle_dynamic_js.dtml*.

          Tree state is set in HTTP cookies. Thus for trees to remember their
          state after you leave the page, cookies must be enabled.

        Attributes:

          'state_id'        -- The string prefix of the HTTP cookies and the session
                               information. Used to differ multiple trees on single
                               page.

          'state_url'       -- The URL of the HTTP cookies. Used to differ multiple
                               trees on single page.

          'state_id'        -- The string prefix of the HTTP cookies. Used to differ
                               multiple trees on single page.

          'sort_order'      -- List of catalog indexes names describing the sorting
                               order.

          'single'          -- Boolean value. Allows only one branch to be expanded at
                               a time. When you expand a new branch, any other expanded
                               branches close. Implemented only for *static* mode.

          'urlparam'        -- A query string which is included in the expanding and
                               contracting widget links. This attribute is for advanced
                               usage only. Implemented only for *static* mode.

          'prefix'          -- Provide versions of the tag variables that start with this
                               string prefix instead of "tree", and that use
                               underscores (_) instead of hyphens (-). The prefix must
                               start with a letter and contain only alphanumeric
                               characters and underscores (_).

          'meta_types'      -- List of meta_types of objects that will be shown on
                               the tree.

          'dynamic'         -- This expression evaluates boolean value that turns
                               *dynamic* mode on or off.

          'pseudo_dynamic'  -- This expression evaluates boolean value that turns
                               *pseudo dynamic* mode on or off.

          'dynamic_item_id' -- string identifier of the item that will present
                               open branches contents in *dynamic* mode.

          'dynamic_item'    -- Set this tag to render open branches content in
                               *dynamic* mode.

        Tag Variables:

          'tree-item-expanded' -- True if the current node is expanded.

          'tree-item-url'      -- The URL of the current node.

          'tree-root-url'      -- The URL of the root node.

          'tree-root-id'       -- The identifier of the root node.

          'tree-level'         -- The depth of the current node. Top-level nodes have
                                  a depth of zero.

        Tag Control Variables:

          You can control the tree tag by setting this variable.

          'collapse_all' -- If this variable is true then the entire tree is
                            collapsed.
    """
    name = 'jungle'
    blockContinuations = ()
    expand = None

    def __init__( self, blocks ):
        tname, args, section = blocks[0]
        args = parse_params( args, dynamic_item=1,
                             name=None, expr=None,
                             sort_order=None,
                             single=1,
                             urlparam=None,
                             prefix=None,
                             state_id=None, state_url=None,
                             meta_types=None,
                             dynamic=1,
                             dynamic_item_id=None,
                             pseudo_dynamic=1,
                             arch=None
                           )
        has_key = args.has_key

        if has_key('') or has_key('name') or has_key('expr'):
            name, expr = name_param( args, 'tree', 1 )
            if expr is not None:
                args['expr'] = expr
            elif has_key(''):
                args['name'] = name
        else:
            name = 'a tree tag'

        try:
            if has_key('meta_types'):
                args['meta_types'] = eval(args['meta_types'])
            else:
                args['meta_types'] = CustomDefs('simple_meta_types')
        except:
            args['meta_types'] = ['Heading', 'Site Container']

        if has_key('sort_order'):
            args['sort_order'] = eval(args['sort_order'])

        if has_key('dynamic'):
            if has_key('pseudo_dynamic'):
                raise ParseError, _tm('dynamic and pseudo_dynamic given', 'tree')

            if type(args['dynamic']) is StringType:
                args['dynamic'] = Eval(args['dynamic']).eval

            if not args.get('dynamic_item_id'):
                #if has_key('arch') and args['arch']:
                #    args['dynamic_item_id'] = 'dynamic_arch_tree_item'
                #else:
                args['dynamic_item_id'] = 'dynamic_tree_item'

        elif has_key('pseudo_dynamic') and type(args['pseudo_dynamic']) is StringType:
            args['pseudo_dynamic'] = Eval(args['pseudo_dynamic']).eval

        #if not has_key('childless_decoration'):
        #    args['childless_decoration']=''

        prefix = args.get('prefix')
        if prefix and not simple_name(prefix):
            raise ParseError, _tm(
                'prefix is not a simple name', 'tree')

        if not has_key('state_id'):
            args['state_id'] = 'jungle'
        if not has_key('state_url'):
            args['state_url'] = '/'

        # following parameters used in isOpened, urlsTree, apply_diff, tpRender, tpRenderTABLE
        args['item_state_dict'] = {} # dictionary that represents item state by url (-1 - closed, 1 - opened, 0 - empty)
        args['state'] = {} # dictionary that represents open items lists in following format:
                           # {url_1 : [id_1, id_2], url_2 : [ id_3 ] }
                           # this means that url_1+id_1, url_1+id_2, url_2+id_3 items opened
        args['parent_url'] = '' # parent_url of root

        self.__name__ = name
        self.section = section.blocks
        self.args = args

    def render( self, md ):
        args = self.args
        have = args.has_key

        if have('name'):
            v = md[args['name']]
        elif have('expr'):
            v = args['expr'].eval( md )
        else:
            v = md.this

        IsDebug = _IsDebug( v )

        if have('dynamic_item'):
            # Dynamic item receiving args through session XXX
            """
            args_name = args['state_id']+'_args'
            args_value = md['REQUEST'].get(args_name, None)
            if IsDebug:
                LOG('JungleTag.render', DEBUG, 'load dynamic: %s\n%s' % ( args_name, args_value ))
            if args_value is not None:
                args.update( _dict(args_value) )
            """
            mode = 'dynamic'
        else:
            mode = 'static'
            for _mode in ('pseudo_dynamic', 'dynamic',):
                if have(_mode):
                    if callable(args[_mode]):
                        mode_set = args[_mode](md)
                    else:
                        mode_set = args[_mode]
                    if mode_set:
                        mode = _mode
                    break

        return tpRender( v, md, self.section, self.args, mode)

    __call__ = render


String.commands['jungle'] = Jungle

pyid = id # Copy builtin

def _dict( list, tree=None ):
    rd = {}
    if tree:
        rs = []
        for k, v in list:
            rd[k] = v
            rs.append(k)
        return ( rd, rs, )
    else:
        for k, v in list:
            rd[k] = v
        return rd

def _getattrs( obj, attrs=[] ):
    return filter(None, map( lambda attr, obj=obj: getattr(obj, attr), attrs ))

def encode_dict( d, state_cleanup=0, url_list=[ ]):
    if state_cleanup:
        # removing ids of deleted folders
        l = map( lambda item, ul=url_list: filterState(item, ul), d.items() )
        # removing urls with empty id lists
        l = filter( lambda item: len(item[1]), l )
        return encode_seq(l)
    return encode_seq(d.items())

def decode_dict( s ):
    return _dict(decode_seq(s))

def apply_diff( state, diff, expand, parent_url ):
    url = parent_url
    if expand:
        diff.reverse() # it is faster (?)
        while diff:
            id = diff.pop(-1)
            if state.has_key(url):
                if id not in state[url]:
                    state[url].append(id)
            else:
                state[url] = [id]
            url += id + '/'
    else:
        url += join(diff[:-1],'/') + '/'
        id = diff[-1]
        if state.has_key(url):
            try:
                state[url].remove(id)
            except ValueError:
                pass

def isOpened( url, state ):
    """
        Checks that url branch is opened
    """
    t = url.rfind('/')+1
    base_url = url[:t]
    id = url[t:]
    try:
        ret = id in state[base_url]
    except KeyError:
        ret = 0
    return ret

def filterState( state_rec, url_list ):
    """
        Filters ids by records that are exist in url_list
    """
    url = state_rec[0]
    state_rec = list(state_rec)
    state_rec[1] = filter(lambda id, url=url, ul=url_list: url+id in ul, state_rec[1])
    return state_rec

def urlsTree( urls, args, mode, base='', skip=0, expand_all=0, url_dict=None ):
    """
        Recursively reorganizes folders list to hierarchical dictionaries tree and builds up 
        item_state dictionary
    """
    ret = {}
    item_state_dict = args['item_state_dict']

    while urls:
        url = urls[0]
        if url.startswith(base+'/'):
            if len(base) and not item_state_dict[base]:
                item_state_dict[base] = (skip and -1) or 1
            del urls[0]
            item_state_dict[url] = 0
            if not skip or mode == 'pseudo_dynamic':
                ret[url] = urlsTree(urls, args, mode, base=url,
                                    skip=not (expand_all or isOpened( url, args['state'] )),
                                    expand_all=expand_all, url_dict=url_dict)
        else:
            break
    # XXX
    if base and url_dict and item_state_dict.has_key(base):
        x = url_dict[base].getChilds() and -1 or 0
        if x and not item_state_dict[base]:
            item_state_dict[base] = x

    return ret

def tpRender( self, md, section, args, mode ):
    """
        Render data organized as a tree
    """
    IsDebug = _IsDebug( self )

    root_path = self.getPhysicalPath()
    root_url = url_unquote(self.REQUEST.physicalPathToURL( root_path, relative=1 ))
    root_path = joinpath( root_path )
    root_id = self.id

    if len(root_path) > len(root_url):
        url_diff = root_path[:-len(root_url)]
        root_url = root_path
    else:
        url_diff = root_url[:-len(root_path)]

    parent_url = root_url[:-len(root_id)]

    if IsDebug:
        LOG('Jungle.tpRender', DEBUG, 'root_path: %s, root_url: %s, root_id: %s' % ( root_path, root_url, root_id ))

    if not args.has_key('dynamic_item'):
        args['parent_url'] = parent_url

    args['portal_url'] = self.portal_url()
    args['item_state_dict'][root_url] = 1

    treeData = { 'tree-root-url'  : root_url, 
                 'tree-root-id'   : root_id, 
                 'tree-item-code' : 'not implemented',
                 'tree-state'     : 'not implemented' }

    md._push( InstanceDict( self, md ) )
    md._push( treeData )

    # Decoding state list
    init_state = { parent_url : [ root_id ] }

    if md.has_key('collapse_all'):
        state = init_state
    elif md.has_key('expand_all'):
        state = init_state  # *TODO*
    else:
        if md.has_key('tree-s' + args['state_id']):
            state=md['tree-s' + args['state_id']]
            try:
                state=decode_dict(state)
            except:
                state=init_state
            if not state.has_key(parent_url) or root_id not in state[parent_url]:
                state=init_state
        else:
            state=init_state

        if md.has_key('tree-e'):
            try:
                diff = decode_seq(md['tree-e'])
            except:
                pass
            else: 
                apply_diff(state, diff, 1, args['parent_url'])

        if md.has_key('tree-c'):
            try:
                diff = decode_seq(md['tree-c'])
            except:
                pass
            else:
                apply_diff(state, diff, 0, args['parent_url'])

    args['state'].clear()
    args['state'].update(state)

    if IsDebug:
        LOG('Jungle.tpRender', DEBUG, 'state: %s' % state)

    expanded = []
    for p in state.keys():
        for x in state[p]:
            u = '%s%s' % (p, x)
            if not u.startswith('/'):
                u = '/'+u
            if u in expanded: continue
            expanded.append( u )

    if IsDebug:
        LOG('Jungle.tpRender', DEBUG, 'expanded: %s' % expanded)

    # Getting folders list from catalog
    catalog = getToolByName( self, 'portal_catalog', None )
    query_items = [ 'Description', ]

    folders_list = catalog.searchTrees( expanded=expanded, query_items=query_items, \
        path=root_path+'%', meta_type=args.get('meta_types') ) or \
        []

    # Building url_dict containing { url : <mybrains...>, ...} ordered by url
    if folders_list and folders_list[0].getPath().startswith(root_url):
        # When root_url and item's getPath are the same we don't need url_diff
        url_dict = _dict( map( lambda folder: ( folder.getPath(), folder ), folders_list ) )
    else:
        url_dict = _dict( map( lambda folder, ud=url_diff: ( ud+folder.getPath(), folder ), folders_list ) )

    del folders_list

    t = CustomCheckFolders( self, url_dict.keys(), root_path ) # XXX

    # Building url_tree
    while root_url in t: t.remove(root_url)

    url_tree = urlsTree( t, args, mode, expand_all=md.has_key('expand_all'), url_dict=url_dict )

    # Applying prefix to treeData
    prefix = args.get('prefix')
    if prefix:
        for k, v in treeData.items():
            treeData[prefix + replace(k[4:], '-', '_')] = v

    # Applying script tag for dynamic and pseudo_dynamic modes
    if mode != 'static':
        ret = '<script language="javascript" src="'+args['portal_url']+'/jungle_dynamic_js"></script>\n'
        if mode == 'dynamic' and not args.has_key('dynamic_item'):
            # Dynamic item passing some args to subbranches using session XXX
            """
            args_name = args['state_id']+'_args'
            args_value = encode_seq([ (k,v) for (k,v) in args.items() if k in transmitted_args ])
            args_url = args['state_url']
            md['RESPONSE'].setCookie(args_name, args_value, path=args_url)
            if IsDebug:
                LOG('JungleTag.tpRender', DEBUG, 'save dynamic: %s\n%s' % ( args_name, args_value ))
            """
            pass
    else:
        ret = ''

    md._push( url_dict[root_url] )
    ret += tpRenderTABLE( self, root_url, url_tree, url_dict, mode, section, md, treeData, level=0, args=args )
    md._pop()

    if not ( args.get('single') or args.has_key('dynamic_item') ):
        args_name = 'tree-s' + args['state_id']
        args_value = encode_dict(args['state'], state_cleanup=1, url_list=url_dict.keys()+[root_url])
        args_url = args['state_url']
        md['RESPONSE'].setCookie(args_name, args_value, path=args_url)
        if IsDebug:
            LOG('JungleTag.tpRender', INFO, 'save single: %s, URL: %s\n%s' % ( \
                args_name, args_url, args['state'] ))

    return ret

def tpRenderTABLE( self, url, url_tree, url_dict, mode, section, md, treeData, level=0, args=None ):
    """
        Render a tree as a table
    """
    IsDebug = _IsDebug( self )

    ret = ''

    self_url = md['URL']
    try: self_url = splitpath( self_url )[1]
    except IndexError: pass

    have_arg = args.has_key

    portal_url = args.get('portal_url','')
    item_state = args['item_state_dict'][url] # XXX
    expanded = (item_state == 1)

    ptreeData = add_with_prefix(treeData, 'tree', args.get('prefix'))
    ptreeData['tree-item-url'] = url
    ptreeData['tree-item-department'] = departmentDictionary.IsDepartmentFolder( context=self, url=url )
    ptreeData['tree-item-expanded'] = expanded
    ptreeData['tree-level'] = level
    ptreeData['tree-colspan'] = 0

    table_head = '<table cellpadding="0" cellspacing="0" border="0" width="100%%" height="100%%">\n'\
                 '<tr><td colspan="2" style="padding: 2px;%s">\n'

    if mode != 'static' and item_state and level:
        ptreeData['tree-item-expanded'] = 0
        ret += ( '<div name="closed" style="display:%s;">\n' + table_head +\
                 '%s\n'\
                 '</td></tr>\n'\
                 '</table>\n'\
                 '</div>\n'\
                 '<div name="opened" style="display:%s;"%s>\n') \
               % ( expanded and 'none' or 'block',
                   '',
                   render_blocks(section, md),
                   expanded and 'block' or 'none',
                   (mode == 'dynamic' and expanded == 0) and ' empty' or '' )
        ptreeData['tree-item-expanded'] = 1

    if IsDebug:
        LOG('Jungle.tpRenderTABLE', DEBUG, 'url_tree:\n%s' % '\n'.join(url_tree.keys()))

    if not ( mode == 'dynamic' and item_state == -1 ):
        # In dynamic mode we don't need following stuff if branch is closed
        ret += table_head \
               % (ptreeData['tree-item-expanded'] and ' background: url('+portal_url+'/thread_I_bg.gif) no-repeat;' or '')

        ret += render_blocks(section, md) + '</td></tr>\n'
        sort_order = args.get('sort_order') or ['Title','id']
        sub_urls = url_tree.keys()

        if len(sub_urls) > 1:
            if sort_order:
                # Sorting urls in sub_urls list
                sub_urls = map( lambda url, a=sort_order, d=url_dict: _getattrs(d[url],a)+[url], sub_urls )
                sub_urls.sort()
                sub_urls = map( lambda item: item[-1], sub_urls )

            if have_arg('reverse'):
                sub_urls = list(sub_urls)
                sub_urls.reverse()

        for i in range(len(sub_urls)):
            # Working on subitems of current item
            sub_url = sub_urls[i]
            branch_end = (i+1==len(sub_urls))

            id = url_dict.get(sub_url).id

            item = url_dict.get(sub_url)
            item_state = args['item_state_dict'][sub_url]

            img_tag = '<%s src="%s/thread_%s%s.gif"'\
                      % ((item_state and (mode != 'static')) and 'input type=image' or 'img',
                         portal_url, (branch_end and 'L' or 'T'), _img_postfix[item_state+1])

            if item_state:

                diff = sub_url[ len(args['parent_url']) : ].split('/')
                s = encode_seq(diff)

                if mode != 'dynamic':
                    if mode == 'pseudo_dynamic':
                        img_tag += ' onClick="javascript:nodeAction(this,\'%s\',\'%s\')">'\
                                    % (args['state_url'], s)
                    else:
                        img_tag += '>'

                        # Propagate extra args through tree.
                        if args.has_key( 'urlparam' ):
                            param = args['urlparam']
                            param = "%s&" % param
                        else:
                            param = ""

                        if item_state == 1: # opened
                            img_tag = '<a href="%s?%stree-c=%s">%s</a>' % ( self_url, param, s, img_tag )
                        else:
                            img_tag = '<a href="%s?%stree-e=%s">%s</a>' % ( self_url, param, s, img_tag )

                else:
                    if args.has_key('dynamic_item_id'):
                        x = args['dynamic_item_id']
                    else:
                        x = 'dynamic_tree_item'
                    img_tag += ' onClick="javascript:nodeAction(this,\'%s\',\'%s\',\'%s/%s\')">'\
                                % ( args['state_url'], s, sub_url, x )
            else:
                img_tag += '>'

            md._push( item )

            ret += '<tr>\n'\
                   '<td%s width="16" valign="top">%s</td>\n'\
                   '<td width="100%%">%s</td>\n'\
                   '</tr>\n'\
                   % (((not branch_end) and ' background="'+portal_url+'/thread_I.gif"' or ''), img_tag,
                      tpRenderTABLE( self, sub_url, url_tree[sub_url], url_dict, mode, section, md, treeData, \
                      level+1, args ))

            md._pop()

        ret += '</table>\n'

    if (mode != 'static') and item_state and level:
        ret += '</div>\n'

    return ret
