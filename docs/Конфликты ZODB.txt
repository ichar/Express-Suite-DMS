Привет всем!
Прошел год, который потребовался для устранения некоторых «неувязок» Zope/ZODB для того, чтобы обеспечить требуемую производительность и вообще возможность нормальной работы.

Высказываюсь туманно. Но может кто помнит, как-то была затея обсудить эту тему в конференциях Zope3/Zope2, и кое-какие высказывания у меня были. Тогда это звучало как POSKeyError, ConflictError, техника коммитов, версии Python/Zope, что лучше 2 или 3 и тд. и тп. Совет был кинуть эту затею и работать как все. Я бы с удовольствием, но, увы, проблема не решалась… Пришлось работать. Сейчас могу сказать четко и определенно (правда, если собирусь с мыслями) - проблема у Зопы есть, однозначно.

Кто-нибудь, возможно, задумывается в своих проектах о том, почему в отдельных случаях Zope в конечном счете отвечает «небыстро». Возможно многие понимают почему, и что проблема в том, что, как правило, потому что часто (увы) ваша система повторяет одну и ту же работу (т.е. одну и ту же транзакцию) дважды и может даже и трижды, и часто не всегда оправданно, по крайней мере, непонятно почему. Хм, не знаю, всех ли это устраивает.

Не хочу залезать в дискуссии. Проблема в резолвинге (разрешении, устранении) конфликтов на объектах, наследованных от коллекции классов BTrees (OOBTree, IOBTree и прочих во всей этой архитектуре). На указанных классах в Zope/ZODB построены такие продукты как ZCatalog и Transience. Зачем они нужны, наверно, знает каждый программист Zope2/Zope3 и Plone, и эти продукты существуют и используются (т.е. имеют место) везде, где есть Zope. Прежде всего, BTrees - это ваша поисковая система и любые ее расширения. Во-вторых, сессия. И как бы вы не работали, сессия будет инициализироваться всегда, неважно используете вы ее фактически или нет. А также и многие другие «вариации», например, BTtreeFolder и т.д и т.п.

Если бы Zope выполнял эту работу (те резолвинг конфликтов BTrees) корректно, то все было бы гуд. Это доказывают тесты (мои тесты, показать их я не могу, нужно тогда показывать всю систему). Но вот беда, Zope, вернее BTrees, с этой работой не справляются. Отсюда и грабли. Вернее справляются, но до определенного момента.

Одним словом, данную проблему мне удалось решить (правда, не устранить первоисточник, а найти решение), могу поделиться опытом, если кому-либо все это будет нужно (может - не нужно и нет у людей проблемы, а только у меня засада).

Что пришлось сделать:

1) Полностью заменить каталог и все его применения. Идея в самом заголовке, не ZCatalog, а ZSQLCatalog. Далее говорить ничего не буду.
2) В модели данных реализовать механизмы резолвинга прикладных конфликтов, построенных на использовании метода _p_resolveConflict.
3) Убрать сессию, вернее устроить ее так, чтобы с ней можно было работать.

Имею следующий результат:

1) Портал в кофигурации с десятью разделами – хранилищами данных (так получилось что 10).
2) Совокупный объем данных: ~30Gb. Кол-во прикладных объектов > 150 тыс. Кол-во объектов ZODB – не берусь считать точно, много, хотя стало значительно меньше после внедрения SQL (каталог все сжирал), на порядок меньше.
3) Более 600 зарегистрированных пользователей. Каждый день работают в среднем 200.
4) Ежедневный прирост данных: в прикладных объектах – 250-300.
5) Длительность средней транзакции в режиме многопоточности (до 10 тредов на раздел/процесс) не превышает 3 сек (разные цифры, иногда 1 сек, иногда 2, бывает и 10, но на то есть причины, а как правило - нажал и получил ответ, неважно когда и неважно кто еще с тобой рядом).

В целом теперь (как программист) я доволен. И пользователи мои вроде бы тоже особо не жалуются. Обслуживаю управляющую компанию крупного промышленного холдинга. Тут, конечно, фиг знает…

Кину пару выдержек их логов (для большей наглядности темы разговора):

2008-10-20T13:37:13 DEBUG Conflict Resolution resolved: (<class 'Products.Transience.Transience.Increaser'>, ())
thread  : 1136679232
storage : temporary storage for sessioning
oid     : 0x0278
class   : <type 'ExtensionClass.ExtensionClass'>
module  : Products.Transience.Transience
forced  : newstate
------
2008-10-20T13:37:13 DEBUG Conflict Resolution resolved: <type 'BTrees._OOBTree.OOBTree'>
thread  : 1136679232
storage : temporary storage for sessioning
oid     : 0x0524
class   : <type 'type'>
module  : BTrees._OOBTree
forced  : newstate
------
2008-10-20T13:37:13 DEBUG Conflict Resolution resolved: <type 'BTrees._IOBTree.IOBucket'>
thread  : 1136679232
storage : temporary storage for sessioning
oid     : 0x052d
class   : <type 'type'>
module  : BTrees._IOBTree
forced  : newstate

…

2008-10-20T12:04:27 DEBUG Schedule.ResolveConflict items: old 117, saved 116, new 118, resolved: 117, key [_tree], mode: 2
------
2008-10-20T12:04:27 DEBUG Conflict Resolution resolved: (<class 'Products.PortalScheduler.Schedule.Schedule'>, ())
thread  : 1126189376
storage : /opt/instances/trading/var/Data.fs
oid     : 0x09e3fe
class   : <type 'ExtensionClass.ExtensionClass'>
module  : Products.PortalScheduler.Schedule

Раньше, на отдельных транзакциях кол-во конфликтов (которые прокручивал BTrees) доходило до сотни в секунду(!!!) Вот и судите сами какая будет тут производительность.

Опять же, будет у кого нужда и интерес, готов потелиться.

С глубоким уважением ко всем участникам сообщества Python/Zope,

ichar.
